package main

import (
	. "aicup2019/model"
	мФмт "fmt"
)

//MyStrategy -- экспортируемая структура для стратегии
type MyStrategy struct{}

//NewMyStrategy -- возвращает указатель на MyStrategy
func NewMyStrategy() MyStrategy {
	return MyStrategy{}
}

//Вычисляет дистанцию до квардрата
func _ДистанцияКвадрат(a Vec2Float64, b Vec2Float64) float64 {
	return (a.X-b.X)*(a.X-b.X) + (a.Y-b.X)*(a.Y-b.Y)
}

//Получает действие для стратегии
func (strategy MyStrategy) getAction(пЮнит Unit, пИгра Game, пОтлад Debug) UnitAction {
	враг := Unit{PlayerId: -1} //Создание врагов

	{ //Выбрать врага
		for _, чужой := range пИгра.Units {
			//Если это свой игрок -- пропустить итерацию
			мФмт.Printf("чужой=%v свой=%v\n%v\n", чужой.PlayerId, пЮнит.PlayerId, чужой)
			if чужой.PlayerId == пЮнит.PlayerId {
				continue
			}
			//Убедиться, что врага нет
			if враг.PlayerId == -1 {
				//Чужой будет врагом
				враг = чужой
				continue
			}
			//Выбрать врага
			дистЧужой := _ДистанцияКвадрат(пЮнит.Position, чужой.Position)
			дистВраг := _ДистанцияКвадрат(пЮнит.Position, враг.Position)
			//Если враг н выбран или дистанция до чужого меньше чем дистанция до врага
			if дистЧужой < дистВраг {
				//Чужой будет врагом
				враг = чужой
			}
		}
	}
	var лутБокс *LootBox
	var оружие *LootBox
	var аптечка *LootBox
	{ // Получить ближайший лутбокс
		for _, _лутБокс := range пИгра.LootBoxes {
			switch _лутБокс.Item.(type) {
			case ItemHealthPack: //Если это аптечка
				//Если здоровье нормальное -- игнорировать
				if пЮнит.Health == 100 {
					continue
				}
				if аптечка == nil {
					аптечка = &_лутБокс
					continue
				}
				//Аптечка уже назначена, может эта ближе?
				дистБокс := _ДистанцияКвадрат(пЮнит.Position, аптечка.Position)
				дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
				//Если расстояние до лутбокса, меньше чем расстояние до оружия
				if дистБокс < дистБоксНов {
					//Назначить оружием текущий лутБокс
					аптечка = &_лутБокс
				}
			case ItemWeapon: //Если оружие -- будем выбирать оружие
				if пЮнит.Weapon != nil {
					continue
				}
				if оружие == nil {
					//Назначить оружием текущий лутБокс
					оружие = &_лутБокс
					continue
				}
				//Оружие уже назначено, может это ближе?
				дистБокс := _ДистанцияКвадрат(пЮнит.Position, оружие.Position)
				дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
				//Если расстояние до лутбокса, меньше чем расстояние до оружия
				if дистБокс < дистБоксНов {
					//Назначить оружием текущий лутБокс
					оружие = &_лутБокс
				}
			case ItemMine: //Если это мина -- и не назначен лутБокс -- выбираем мину
				if лутБокс == nil {
					if оружие == nil || аптечка == nil {
						//Назначить оружием текущий лутБокс
						лутБокс = &_лутБокс
						continue
					}
				}
				//лутБокс уже назначен, может этот ближе?
				дистБокс := _ДистанцияКвадрат(пЮнит.Position, лутБокс.Position)
				дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
				//Если расстояние до лутбокса, меньше чем расстояние до лутБокса текущего
				if дистБокс < дистБоксНов {
					//Назначить оружием текущий лутБокс
					лутБокс = &_лутБокс
				}

			}
		}
	}
	/*
		{ //Выбрать из всех лутБоксов лутБокс
			for _, лутБокс := range пИгра.LootBoxes {
				switch лутБокс.Item.(type) {
				case *ItemWeapon:
					бОружие := оружие == nil
					дистБокс := _ДистанцияКвадрат(пЮнит.Position, лутБокс.Position)
					дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, оружие.Position)
					//Если расстояние до лутбокса, меньше чем расстояние до оружия
					бДистанция := дистБокс < дистБоксНов
					if бОружие || бДистанция {
						//Назначить оружием текущий лутБокс
						оружие = &лутБокс
					}
				}
			}
		}
	*/
	позЦель := пЮнит.Position
	цель := ""
	{ //Выбрать цель
		//Если нет вообще ничего -- идти к лутБоксу
		if пЮнит.Weapon == nil && оружие != nil { //Если вообще нет ничего
			позЦель = оружие.Position
			цель = "оружие"
		} else if аптечка != nil {
			позЦель = аптечка.Position
			цель = "аптечка"
			//Если оружие есть -- выбрать себе врага
		} else if враг.PlayerId != -1 {
			позЦель = враг.Position
			цель = "враг"
			//Если нет врага -- то хоть лутБокс взять
		} else if лутБокс != nil {
			позЦель = лутБокс.Position
			цель = "лутБокс"
		} else {
			цель = "нет"
		}
	}

	//Создать прицел
	прицел := Vec2Float64{
		X: 0,
		Y: 0,
	}
	{ //Выбрать прицел по врагу
		//Если выбран враг -- прицел назначить п оврагу
		if враг.PlayerId != -1 {
			прицел = Vec2Float64{
				X: враг.Position.X - пЮнит.Position.X,
				Y: враг.Position.Y - пЮнит.Position.Y,
			}
		}
	}
	//Если по высоте цель выше юнита
	бПрыжок := позЦель.Y > пЮнит.Position.Y
	{ // Выбрать прыжок
		бХ := позЦель.X > пЮнит.Position.X
		тайлСправа := пИгра.Level.Tiles[int(пЮнит.Position.X+1)][int(пЮнит.Position.Y)]
		бТайл := (тайлСправа == TileWall) || (тайлСправа == TileLadder)
		if бХ && бТайл {
			бПрыжок = true
		}
		if !бПрыжок {
			бХ = позЦель.X < пЮнит.Position.X
			тайлСлева := пИгра.Level.Tiles[int(пЮнит.Position.X-1)][int(пЮнит.Position.Y)]
			бТайл = (тайлСлева == TileWall) || (тайлСлева == TileLadder)
			if бХ && бТайл {
				бПрыжок = true
			}
		}
	}
	//Отладочная печать
	пОтлад.Draw(CustomDataLog{
		Text: мФмт.Sprintf("игроков=%v врагНомер=%v юнитНомер=%v  здоров=%v цель=%v", len(пИгра.Units), враг.PlayerId, пЮнит.PlayerId, пЮнит.Health, цель),
	})
	return UnitAction{
		Velocity:   позЦель.X - пЮнит.Position.X - 10,
		Jump:       бПрыжок,
		JumpDown:   !бПрыжок,
		Aim:        прицел,
		SwapWeapon: false,
		PlantMine:  true,
		Shoot:      true,
	}
}
