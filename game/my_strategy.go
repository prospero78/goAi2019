package main

import (
	. "aicup2019/model"
	мФмт "fmt"
	мМат "math"
)

//MyStrategy -- экспортируемая структура для стратегии
type MyStrategy struct{}

var (
	лутБокс, оружие, аптечка *LootBox

	позЦель      Vec2Float64
	цельДвиг     string
	враг         Unit
	бВрагБлизко  bool
	дистВраг     float64
	бПрыжок      bool
	бАптечкаВыше bool
	бОгонь       bool
	бЕстьСтена   bool
)

//NewMyStrategy -- возвращает указатель на MyStrategy
func NewMyStrategy() MyStrategy {
	return MyStrategy{}
}

//Вычисляет дистанцию до квардрата
func _ДистанцияКвадрат(a Vec2Float64, b Vec2Float64) float64 {
	return (a.X-b.X)*(a.X-b.X) + (a.Y-b.X)*(a.Y-b.Y)
}

//Получает действие для стратегии
func (strategy MyStrategy) getAction(пЮнит Unit, пИгра Game, пОтлад Debug) UnitAction {
	враг = Unit{PlayerId: -1} //Создание врагов

	{ //Выбрать врага
		_ВрагВыбрать(пИгра, пЮнит)
	}
	позЦель = пЮнит.Position
	//Создать прицел
	прицел := Vec2Float64{
		X: 0,
		Y: 0,
	}
	{ //Выбрать прицел по врагу
		//Если выбран враг -- прицел назначить п оврагу
		if враг.PlayerId != -1 {
			прицел = Vec2Float64{
				X: враг.Position.X - пЮнит.Position.X,
				Y: враг.Position.Y - пЮнит.Position.Y,
			}
		}
	}
	/*
		//Если по высоте цель выше юнита
		бПрыжок = позЦель.Y > пЮнит.Position.Y
		{ // Выбрать прыжок
			бХ := позЦель.X > пЮнит.Position.X
			тайлСправа := пИгра.Level.Tiles[int(пЮнит.Position.X+1)][int(пЮнит.Position.Y)]
			бТайл := (тайлСправа == TileWall) || (тайлСправа == TileLadder)
			if бХ && бТайл {
				бПрыжок = true
			} else {
				бХ = позЦель.X < пЮнит.Position.X
				тайлСлева := пИгра.Level.Tiles[int(пЮнит.Position.X-1)][int(пЮнит.Position.Y)]
				бТайл = (тайлСлева == TileWall) || (тайлСлева == TileLadder)
				if бХ && бТайл {
					бПрыжок = true
				}
			}
		}
	*/
	_ЕстьСтена(пЮнит, пИгра)
	_ВрагБлизко(пЮнит)
	_ПрыжокВыбрать(пЮнит)
	// Получить ближайший лутбокс
	_ЛутВыбрать(пЮнит, пИгра.LootBoxes)
	//Выбрать цель
	_ДвигВыбрать(пЮнит)
	//Отладочная печать
	if оружие != nil {
		пОтлад.Draw(CustomDataLog{
			Text: мФмт.Sprintf("оруж=%v дистВраг=%.2f цельДвиг=%v огонь=%v позЦель=%v позОруж=%v",
				пЮнит.Weapon != nil,
				дистВраг,
				цельДвиг,
				бОгонь,
				позЦель,
				оружие.Position)})
	} else {
		пОтлад.Draw(CustomDataLog{
			Text: мФмт.Sprintf("оруж=%v дистВраг=%.2f цельДвиг=%v огонь=%v позЦель=%v позОруж=%v",
				пЮнит.Weapon != nil,
				дистВраг,
				цельДвиг,
				бОгонь,
				позЦель,
				nil)})
	}

	return UnitAction{
		Velocity:   _Скорость(пЮнит), //Скорость движения к цели
		Jump:       бПрыжок,
		JumpDown:   !бПрыжок,
		Aim:        прицел,
		SwapWeapon: false,
		PlantMine:  true,
		Shoot:      бОгонь,
	}
}

//Выбирает врага
func _ВрагВыбрать(пИгра Game, пЮнит Unit) {
	for _, чужой := range пИгра.Units {
		//Если это свой игрок -- пропустить итерацию
		if чужой.PlayerId == пЮнит.PlayerId {
			continue
		}
		//Убедиться, что врага нет
		if враг.PlayerId == -1 {
			//Чужой будет врагом
			враг = чужой
			continue
		}
		//Выбрать врага
		дистЧужой := _ДистанцияКвадрат(пЮнит.Position, чужой.Position)
		дистВраг := _ДистанцияКвадрат(пЮнит.Position, враг.Position)
		//Если враг н выбран или дистанция до чужого меньше чем дистанция до врага
		if дистЧужой < дистВраг {
			//Чужой будет врагом
			враг = чужой
		}
	}
}

//Выбирает цель движения
func _ДвигВыбрать(пЮнит Unit) {
	_ВрагСближение := func() (цель Vec2Float64) {
		/*
			Нельзя вплотную стоять к врагу.
			Особенно когда он снизу.
		*/
		дистХ := враг.Position.X - пЮнит.Position.X
		switch дистХ > 0 {
		case true: // Враг правее
			цель.X = враг.Position.X - 2
		case false: //Враг левее
			цель.X = враг.Position.X + 2
		}
		дистУ := враг.Position.Y - пЮнит.Position.Y
		switch дистУ > 0 {
		case true: // Враг выше и это хорошо
			цель.Y = враг.Position.Y - 2
		case false: //Враг ниже и это жопа. Прыгаем вверх
			цель.Y = пЮнит.Position.Y + 10
		}
		return цель
	}
	_АптечкаСближение := func() (цель Vec2Float64) {
		/*
			Если двигаться к аптечке -- то прям на неё
			Особенно когда он снизу.
		*/
		дистХ := аптечка.Position.X - пЮнит.Position.X
		switch дистХ > 0 {
		case true: // Аптечка правее
			цель.X = аптечка.Position.X + 2
		case false: //Аптечка левее
			цель.X = аптечка.Position.X - 2
		}
		дистУ := аптечка.Position.Y - пЮнит.Position.Y
		switch дистУ > 0 {
		case true: // Аптечка выше
			цель.Y = аптечка.Position.Y + 5
		case false: //Аптечка ниже. Прыгаем вниз
			цель.Y = аптечка.Position.Y - 5
		}
		return цель
	}
	//Если нет вообще ничего -- идти к лутБоксу
	if пЮнит.Weapon == nil { //Если вообще нет оружия
		позЦель = оружие.Position
		цельДвиг = "оружие"
	} else if аптечка != nil && пЮнит.Health < 100 { //Если есть оружие -- теперь главное здоровье
		позЦель = _АптечкаСближение()
		цельДвиг = "аптечка"
		//Если оружие есть -- выбрать себе врага
	} else if враг.PlayerId != -1 {
		позЦель = _ВрагСближение()
		цельДвиг = "враг"
		//Если нет врага -- то хоть лутБокс взять
	} else if лутБокс != nil {
		позЦель = лутБокс.Position
		цельДвиг = "лутБокс"
	} else {
		цельДвиг = "нет"
	}
}

//Выбирает наиболее необходимый лут на текущем тике
func _ЛутВыбрать(пЮнит Unit, пЛуты []LootBox) {
	//Сбросить все луты, так как их уже может быть подобрали
	аптечка = nil
	оружие = nil
	лутБокс = nil
	for _, _лутБокс := range пЛуты {
		switch _лутБокс.Item.(type) {
		case ItemHealthPack: //Если это аптечка
			//Главное -- это здоровье. Даже если 100% -- надо знать, где лежит аптечка
			if аптечка == nil {
				аптечка = &_лутБокс
				continue
			}
			//Аптечка уже назначена, может эта ближе?
			дистБокс := _ДистанцияКвадрат(пЮнит.Position, аптечка.Position)
			дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
			//Если расстояние до лутбокса, меньше чем расстояние до оружия
			if дистБокс < дистБоксНов {
				//Назначить оружием текущий лутБокс
				аптечка = &_лутБокс
			}
		case ItemWeapon: //Если оружие -- будем выбирать оружие
			if пЮнит.Weapon != nil {
				continue
			}
			if оружие == nil {
				//Назначить оружием текущий лутБокс
				оружие = &_лутБокс
				continue
			}
			//Оружие уже назначено, может это ближе?
			дистБокс := _ДистанцияКвадрат(пЮнит.Position, оружие.Position)
			дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
			//Если расстояние до лутбокса, меньше чем расстояние до оружия
			if дистБокс < дистБоксНов {
				//Назначить оружием текущий лутБокс
				оружие = &_лутБокс
			}
		case ItemMine: //Если это мина -- и не назначен лутБокс -- выбираем мину
			if лутБокс == nil {
				if оружие == nil || аптечка == nil {
					//Назначить оружием текущий лутБокс
					лутБокс = &_лутБокс
				}
				continue
			}
			//лутБокс уже назначен, может этот ближе?
			дистБокс := _ДистанцияКвадрат(пЮнит.Position, лутБокс.Position)
			дистБоксНов := _ДистанцияКвадрат(пЮнит.Position, _лутБокс.Position)
			//Если расстояние до лутбокса, меньше чем расстояние до лутБокса текущего
			if дистБокс < дистБоксНов {
				//Назначить оружием текущий лутБокс
				лутБокс = &_лутБокс
			}

		}
	}
}

func _Скорость(пЮнит Unit) float64 {
	рез := позЦель.X - пЮнит.Position.X
	switch бВрагБлизко {
	case true:
		return рез / 3
	default:
		if рез > 0 {
			return 500
		}
		return -500
	}
}

//Контролирует близость врага.
//Если далеко -- запрет стрельбы
func _ВрагБлизко(пЮнит Unit) {
	дистХ := враг.Position.X - пЮнит.Position.X
	дистУ := враг.Position.Y - пЮнит.Position.Y
	дистВраг = мМат.Sqrt(мМат.Pow(дистХ, 2) + мМат.Pow(дистУ, 2))
	if дистВраг < 18 {
		бВрагБлизко = true
		if !бЕстьСтена {
			бОгонь = true
		}
		бПрыжок = false
		return
	}
	бВрагБлизко = false
	бОгонь = false
}

func _ПрыжокВыбрать(пЮнит Unit) {
	/*
		Выбирает возможность прыжка.
		Прыжок обязателен, если противник рядом
	*/
	бПрыжок = false
	//Если нет оружия -- надо выбирать оружие
	if пЮнит.Weapon == nil && пЮнит.Health > 75 {
		бПрыжок = true
	} else if аптечка != nil { ////Оружие есть -- теперь аптечка
		аптУ := аптечка.Position.Y - пЮнит.Position.Y
		if аптУ > 0 { //Аптечка выше
			бПрыжок = true
			return
		}
		//Значит аптечка ниже
		бПрыжок = false
	} else if бВрагБлизко { //Если враг близко -- не прыгаем, сводимся
		бПрыжок = false
	} else {
		бПрыжок = true
	}
}

func _ЕстьСтена(пЮнит Unit, пИгра Game) {
	/*
		Проходит по циклу, ищет препятствия для стрельбы
	*/
	дельтаХ := (враг.Position.X - пЮнит.Position.X) / 50
	дельтаУ := (враг.Position.Y - пЮнит.Position.Y) / 50
	времХ := пЮнит.Position.X
	времY := пЮнит.Position.Y
	for !(времХ < враг.Position.X && времY < враг.Position.Y) {
		тайл := пИгра.Level.Tiles[int(времХ)][int(времY)]
		времХ += дельтаХ
		времY += дельтаУ
		if тайл == TileWall {
			бЕстьСтена = true
			return
		}
	}
	бЕстьСтена = false
}
